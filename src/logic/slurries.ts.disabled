import { Quantity } from '@/schemas/common';
import { convert } from '@/utils/units';
import { Warning } from '@/utils/guardrails';
import { reynolds, churchillF } from './friction';

export interface ParticleProperties {
  density: Quantity; // kg/m³ (particle density)
  diameter: Quantity; // m (particle diameter)
  shape?: 'spherical' | 'angular' | 'flat'; // Particle shape factor
}

export interface SlurryProperties {
  carrierFluid: {
    density: Quantity; // kg/m³
    viscosity: Quantity; // Pa·s
  };
  particles: ParticleProperties;
  concentration: Quantity; // Volume fraction (0-1) or weight fraction
  concentrationType: 'volume' | 'weight'; // Type of concentration measurement
}

export interface PipeGeometry {
  diameter: Quantity; // m
  length: Quantity; // m
  roughness: Quantity; // m
}

export interface SlurryFlowInput {
  slurry: SlurryProperties;
  pipe: PipeGeometry;
  velocity: Quantity; // m/s
}

export interface SettlingVelocityResult {
  settlingVelocity: Quantity; // m/s
  reynoldsNumber: number;
  dragCoefficient: number;
  method: 'stokes' | 'intermediate' | 'newton' | 'durand';
  warnings: (string | Warning)[];
  metadata: {
    input: SlurryFlowInput;
    calculations: {
      particleReynolds: number;
      archimedesNumber: number;
      shapeFactor: number;
    };
  };
}
export interface ParticleProperties {
  density: Quantity; // kg/m³ (particle density)

  diameter: Quantity; // m (particle diameter)
  shape?: 'spherical' | 'angular' | 'flat'; // Particle shape factor
}

export interface SlurryProperties {
  carrierFluid: {
    density: Quantity; // kg/m³
    viscosity: Quantity; // Pa·s
  };
  particles: ParticleProperties;
  concentration: Quantity; // Volume fraction (0-1) or weight fraction
  concentrationType: 'volume' | 'weight'; // Type of concentration measurement
}

export interface PipeGeometry {
  diameter: Quantity; // m
  length: Quantity; // m
  roughness: Quantity; // m
}

export interface SlurryFlowInput {
  slurry: SlurryProperties;
  pipe: PipeGeometry;
  velocity: Quantity; // m/s
}

export interface SettlingVelocityResult {
  settlingVelocity: Quantity; // m/s
  reynoldsNumber: number;
  dragCoefficient: number;
  method: 'stokes' | 'intermediate' | 'newton' | 'durand';
  warnings: (string | Warning)[];
  metadata: {
    input: SlurryFlowInput;
    calculations: {
      particleReynolds: number;
      archimedesNumber: number;
      shapeFactor: number;
    };
  };
}

export interface SlurryHeadlossResult {
  headloss: Quantity; // m
  pressureDrop: Quantity; // Pa
  frictionFactor: number;
  relativeRoughness: number;
  durandFactor: number;
  concentrationEffect: number;
  warnings: (string | Warning)[];
  metadata: {
    input: SlurryFlowInput;
    calculations: {
      reynoldsNumber: number;
      carrierFrictionFactor: number;
      settlingVelocity: number;
      concentration: number;
    };
  };
}

// Particle shape factors (drag coefficient multipliers)
const SHAPE_FACTORS = {
  spherical: 1.0,
  angular: 1.5,
  flat: 2.0,
} as const;

// Gravitational acceleration
const G = 9.81; // m/s²

/**
 * Calculate particle Reynolds number
 * Re_p = ρ_f * V_s * d_p / μ_f
 * @param fluidDensity - Carrier fluid density (kg/m³)
 * @param settlingVelocity - Particle settling velocity (m/s)
 * @param particleDiameter - Particle diameter (m)
 * @param fluidViscosity - Carrier fluid viscosity (Pa·s)
 * @returns Particle Reynolds number
 */
export function particleReynolds(
  fluidDensity: number,
  settlingVelocity: number,
  particleDiameter: number,
  fluidViscosity: number
): number {
  return (fluidDensity * settlingVelocity * particleDiameter) / fluidViscosity;
}

/**
 * Calculate Archimedes number
 * Ar = (ρ_p - ρ_f) * ρ_f * g * d_p³ / μ_f²
 * @param particleDensity - Particle density (kg/m³)
 * @param fluidDensity - Carrier fluid density (kg/m³)
 * @param particleDiameter - Particle diameter (m)
 * @param fluidViscosity - Carrier fluid viscosity (Pa·s)
 * @returns Archimedes number
 */
export function archimedesNumber(
  particleDensity: number,
  fluidDensity: number,
  particleDiameter: number,
  fluidViscosity: number
): number {
  const densityDifference = particleDensity - fluidDensity;
  return (
    (densityDifference * fluidDensity * G * Math.pow(particleDiameter, 3)) /
    Math.pow(fluidViscosity, 2)
  );
}

/**
 * Calculate drag coefficient based on Reynolds number
 * @param reynoldsNumber - Particle Reynolds number
 * @returns Drag coefficient
 */
export function dragCoefficient(reynoldsNumber: number): number {
  if (reynoldsNumber < 0.1) {
    // Stokes regime (laminar)
    return 24 / reynoldsNumber;
  } else if (reynoldsNumber < 1000) {
    // Intermediate regime
    return (24 / reynoldsNumber) * (1 + 0.15 * Math.pow(reynoldsNumber, 0.687));
  } else {
    // Newton regime (turbulent)
    return 0.44;
  }
}

/**
 * Calculate particle settling velocity using appropriate correlation
 * @param particleDensity - Particle density (kg/m³)
 * @param fluidDensity - Carrier fluid density (kg/m³)
 * @param particleDiameter - Particle diameter (m)
 * @param fluidViscosity - Carrier fluid viscosity (Pa·s)
 * @param shapeFactor - Particle shape factor (1.0 for spherical)
 * @returns Settling velocity (m/s)
 */
export function settlingVelocity(
  particleDensity: number,
  fluidDensity: number,
  particleDiameter: number,
  fluidViscosity: number,
  shapeFactor: number = 1.0
): {
  froudeNumber: number;
  velocity: number;
  method: 'stokes' | 'intermediate' | 'newton' | 'durand';
  dragCoeff: number;
} {
  const warnings: (string | Warning)[] = [];

  // Validate inputs
  if (
    particleDensity <= 0 ||
    fluidDensity <= 0 ||
    particleDiameter <= 0 ||
    fluidViscosity <= 0
  ) {
    throw new Error('All input parameters must be positive');
  }

  if (particleDensity <= fluidDensity) {
    throw new Error(
      'Particle density must be greater than fluid density for settling'
    );
  }

  if (shapeFactor <= 0) {
    throw new Error('Shape factor must be positive');
  }

  // Calculate Archimedes number
  const ar = archimedesNumber(
    particleDensity,
    fluidDensity,
    particleDiameter,
    fluidViscosity
  );

  let velocity: number;
  let method: 'stokes' | 'intermediate' | 'newton' | 'durand';
  let dragCoeff: number;

  if (ar < 36) {
    // Stokes regime
    velocity =
      ((particleDensity - fluidDensity) * G * Math.pow(particleDiameter, 2)) /
      (18 * fluidViscosity);
    method = 'stokes';
    dragCoeff = 24; // For Re < 0.1
  } else if (ar < 83000) {
    // Intermediate regime
    velocity =
      Math.pow(
        (4 * (particleDensity - fluidDensity) * G * particleDiameter) /
          (3 * fluidDensity),
        0.5
      ) * Math.pow(ar / (18 + 0.6 * Math.pow(ar, 0.5)), 0.5);
    method = 'intermediate';
    dragCoeff = 24 * (1 + 0.15 * Math.pow(ar / 24, 0.687));
  } else {
    // Newton regime
    velocity = Math.pow(
      (3.1 * (particleDensity - fluidDensity) * G * particleDiameter) /
        fluidDensity,
      0.5
    );
    method = 'newton';
    dragCoeff = 0.44;
  }

  // Apply shape factor correction
  velocity = velocity / Math.sqrt(shapeFactor);

  // Check for very small particles (may need special handling)
  if (particleDiameter < 1e-6) {
    warnings.push({
      type: 'general',
      message: 'Very small particles (< 1 μm) may require special correlations',
      severity: 'medium',
    });
  }

  // Check for very large particles
  if (particleDiameter > 0.01) {
    warnings.push({
      type: 'general',
      message: 'Large particles (> 10 mm) may not follow standard correlations',
      severity: 'medium',
    });
  }

  return {
    froudeNumber, velocity, method, dragCoeff };
}

/**
 * Calculate Durand factor for slurry flow
 * @param settlingVelocity - Particle settling velocity (m/s)
 * @param pipeDiameter - Pipe diameter (m)
 * @param flowVelocity - Flow velocity (m/s)
 * @param concentration - Volume concentration (0-1)
 * @returns Durand factor
 */
export function durandFactor(
  settlingVelocity: number,
  pipeDiameter: number,
  flowVelocity: number,
  concentration: number
): number {
  if (flowVelocity <= 0) {
    throw new Error('Flow velocity must be positive');
  }

  if (concentration <= 0 || concentration >= 1) {
    throw new Error('Concentration must be between 0 and 1');
  }

  // Durand factor calculation
  // C_D = 180 * (V_s / V) * (g * D / V²)^0.5 * C_v^0.5
  const durandFactor =
    180 *
    (settlingVelocity / flowVelocity) *
    Math.pow((G * pipeDiameter) / Math.pow(flowVelocity, 2), 0.5) *
    Math.pow(concentration, 0.5);

  return durandFactor;
}

/**
 * Calculate slurry headloss using Durand correlation
 * @param carrierDensity - Carrier fluid density (kg/m³)
 * @param carrierViscosity - Carrier fluid viscosity (Pa·s)
 * @param flowVelocity - Flow velocity (m/s)
 * @param pipeDiameter - Pipe diameter (m)
 * @param pipeLength - Pipe length (m)
 * @param pipeRoughness - Pipe roughness (m)
 * @param settlingVelocity - Particle settling velocity (m/s)
 * @param concentration - Volume concentration (0-1)
 * @returns Headloss (m)
 */
export function slurryHeadloss(
  carrierDensity: number,
  carrierViscosity: number,
  flowVelocity: number,
  pipeDiameter: number,
  pipeLength: number,
  pipeRoughness: number,
  settlingVelocity: number,
  concentration: number
): {
  froudeNumber: number;
  headloss: number;
  frictionFactor: number;
  durandFactor: number;
} {
  const warnings: (string | Warning)[] = [];

  // Validate inputs
  if (
    carrierDensity <= 0 ||
    carrierViscosity <= 0 ||
    flowVelocity <= 0 ||
    pipeDiameter <= 0 ||
    pipeLength <= 0 ||
    pipeRoughness < 0
  ) {
    throw new Error('All input parameters must be positive');
  }

  if (concentration <= 0 || concentration >= 1) {
    throw new Error('Concentration must be between 0 and 1');
  }

  // Calculate carrier fluid friction factor
  const reynoldsNumber = reynolds(
    carrierDensity,
    flowVelocity,
    pipeDiameter,
    carrierViscosity
  );
  const relativeRoughness = pipeRoughness / pipeDiameter;
  const carrierFrictionFactor = churchillF(reynoldsNumber, relativeRoughness);

  // Calculate carrier fluid headloss
  const carrierHeadloss =
    (carrierFrictionFactor * pipeLength * Math.pow(flowVelocity, 2)) /
    (2 * G * pipeDiameter);

  // Calculate Durand factor
  const durandFactorValue = durandFactor(
    settlingVelocity,
    pipeDiameter,
    flowVelocity,
    concentration
  );

  // Calculate Froude number
  const froudeNumber = flowVelocity / Math.sqrt(G * pipeDiameter);

  // Check applicability limits
  if (froudeNumber < 1.5) {
    warnings.push({
      type: 'general',
      message: 'Froude number < 1.5: Durand correlation may not be applicable',
      severity: 'high',
    });
  }

  if (froudeNumber > 40) {
    warnings.push({
      type: 'general',
      message: 'Froude number > 40: Durand correlation may not be applicable',
      severity: 'high',
    });
  }

  if (concentration > 0.15) {
    warnings.push({
      type: 'general',
      message:
        'High concentration (> 15%): Durand correlation may not be applicable',
      severity: 'medium',
    });
  }

  // Calculate slurry headloss using Durand correlation
  // i_s = i_w * (1 + C_D * C_v)
  const slurryHeadlossValue =
    carrierHeadloss * (1 + durandFactorValue * concentration);

  return {
    froudeNumber,
    headloss: slurryHeadlossValue,
    frictionFactor: carrierFrictionFactor,
    durandFactor: durandFactorValue,
  };
}

/**
 * Calculate settling velocity for slurry particles
 * @param input - Slurry flow input parameters
 * @returns Settling velocity result
 */
export function calculateSettlingVelocity(
  input: SlurryFlowInput
): SettlingVelocityResult {
  const warnings: (string | Warning)[] = [];

  // Convert input parameters to SI units
  const particleDensity = convert(
    input.slurry.particles.density,
    'kg/m³'
  ).value;
  const particleDiameter = convert(input.slurry.particles.diameter, 'm').value;
  const fluidDensity = convert(
    input.slurry.carrierFluid.density,
    'kg/m³'
  ).value;
  const fluidViscosity = convert(
    input.slurry.carrierFluid.viscosity,
    'Pa·s'
  ).value;

  // Get shape factor
  const shapeFactor = input.slurry.particles.shape
    ? SHAPE_FACTORS[input.slurry.particles.shape]
    : 1.0;

  // Calculate settling velocity
  const { velocity, method, dragCoeff } = settlingVelocity(
    particleDensity,
    fluidDensity,
    particleDiameter,
    fluidViscosity,
    shapeFactor
  );

  // Calculate particle Reynolds number
  const particleRe = particleReynolds(
    fluidDensity,
    velocity,
    particleDiameter,
    fluidViscosity
  );

  // Calculate Archimedes number
  const ar = archimedesNumber(
    particleDensity,
    fluidDensity,
    particleDiameter,
    fluidViscosity
  );

  // Add warnings for extreme conditions
  if (particleRe > 1000) {
    warnings.push({
      type: 'general',
      message: 'High particle Reynolds number: turbulent settling regime',
      severity: 'medium',
    });
  }

  if (ar > 100000) {
    warnings.push({
      type: 'general',
      message:
        'Very high Archimedes number: Newton regime with high uncertainty',
      severity: 'medium',
    });
  }

  return {
    froudeNumber,
    settlingVelocity: { value: velocity, unit: 'm/s' },
    reynoldsNumber: particleRe,
    dragCoefficient: dragCoeff,
    method,
    warnings,
    metadata: {
      input,
      calculations: {
        particleReynolds: particleRe,
        archimedesNumber: ar,
        shapeFactor,
      },
    },
  };
}

/**
 * Calculate slurry headloss using Durand correlation
 * @param input - Slurry flow input parameters
 * @returns Slurry headloss result
 */
export function calculateSlurryHeadloss(
  input: SlurryFlowInput
): SlurryHeadlossResult {
  const warnings: (string | Warning)[] = [];

  // Convert input parameters to SI units
  const carrierDensity = convert(
    input.slurry.carrierFluid.density,
    'kg/m³'
  ).value;
  const carrierViscosity = convert(
    input.slurry.carrierFluid.viscosity,
    'Pa·s'
  ).value;
  const flowVelocity = convert(input.velocity, 'm/s').value;
  const pipeDiameter = convert(input.pipe.diameter, 'm').value;
  const pipeLength = convert(input.pipe.length, 'm').value;
  const pipeRoughness = convert(input.pipe.roughness, 'm').value;

  // Convert concentration to volume fraction
  let concentration: number;
  if (input.slurry.concentrationType === 'volume') {
    concentration = convert(input.slurry.concentration, 'dimensionless').value;
  } else {
    // Convert weight fraction to volume fraction
    const particleDensity = convert(
      input.slurry.particles.density,
      'kg/m³'
    ).value;
    const weightFraction = convert(
      input.slurry.concentration,
      'dimensionless'
    ).value;
    concentration =
      weightFraction /
      particleDensity /
      (weightFraction / particleDensity +
        (1 - weightFraction) / carrierDensity);
  }

  // Calculate settling velocity
  const particleDensity = convert(
    input.slurry.particles.density,
    'kg/m³'
  ).value;
  const particleDiameter = convert(input.slurry.particles.diameter, 'm').value;
  const shapeFactor = input.slurry.particles.shape
    ? SHAPE_FACTORS[input.slurry.particles.shape]
    : 1.0;

  const { velocity: settlingVelocityValue } = settlingVelocity(
    particleDensity,
    carrierDensity,
    particleDiameter,
    carrierViscosity,
    shapeFactor
  );

  // Calculate slurry headloss
  const {
    headloss,
    frictionFactor,
    durandFactor: durandFactorValue,
  } = slurryHeadloss(
    carrierDensity,
    carrierViscosity,
    flowVelocity,
    pipeDiameter,
    pipeLength,
    pipeRoughness,
    settlingVelocityValue,
    concentration
  );

  // Calculate pressure drop
  const pressureDrop = headloss * carrierDensity * G;

  // Calculate relative roughness
  const relativeRoughness = pipeRoughness / pipeDiameter;

  // Calculate Reynolds number
  const reynoldsNumber = reynolds(
    carrierDensity,
    flowVelocity,
    pipeDiameter,
    carrierViscosity
  );

  // Add concentration effect calculation
  const concentrationEffect = 1 + durandFactorValue * concentration;

  const froudeNumber = flowVelocity / Math.sqrt(G * pipeDiameter);

  // Add warnings for applicability
  if (froudeNumber < 1.5 || froudeNumber > 40) {
    warnings.push({
      type: 'general',
      message: `Froude number (${froudeNumber.toFixed(2)}) outside recommended range (1.5-40)`,
      severity: 'high',
    });
  }

  if (concentration > 0.15) {
    warnings.push({
      type: 'general',
      message: `High concentration (${(concentration * 100).toFixed(1)}%): Durand correlation may not be applicable`,
      severity: 'medium',
    });
  }

  if (particleDiameter / pipeDiameter > 0.1) {
    warnings.push({
      type: 'general',
      message:
        'Large particle-to-pipe diameter ratio: Durand correlation may not be applicable',
      severity: 'high',
    });
  }

  return {
    froudeNumber,
    headloss: { value: headloss, unit: 'm' },
    pressureDrop: { value: pressureDrop, unit: 'Pa' },
    frictionFactor,
    relativeRoughness,
    durandFactor: durandFactorValue,
    froudeNumber,
    concentrationEffect,
    warnings,
    metadata: {
      input,
      calculations: {
        reynoldsNumber,
        carrierFrictionFactor: frictionFactor,
        settlingVelocity: settlingVelocityValue,
        concentration,
      },
    },
  };
}


// Particle shape factors (drag coefficient multipliers)
const SHAPE_FACTORS = {
  spherical: 1.0,
  angular: 1.5,
  flat: 2.0,
} as const;

// Gravitational acceleration
const G = 9.81; // m/s²

/**
 * Calculate particle Reynolds number
 * Re_p = ρ_f * V_s * d_p / μ_f
 * @param fluidDensity - Carrier fluid density (kg/m³)
 * @param settlingVelocity - Particle settling velocity (m/s)
 * @param particleDiameter - Particle diameter (m)
 * @param fluidViscosity - Carrier fluid viscosity (Pa·s)
 * @returns Particle Reynolds number
 */
export function particleReynolds(
  fluidDensity: number,
  settlingVelocity: number,
  particleDiameter: number,
  fluidViscosity: number
): number {
  return (fluidDensity * settlingVelocity * particleDiameter) / fluidViscosity;
}

/**
 * Calculate Archimedes number
 * Ar = (ρ_p - ρ_f) * ρ_f * g * d_p³ / μ_f²
 * @param particleDensity - Particle density (kg/m³)
 * @param fluidDensity - Carrier fluid density (kg/m³)
 * @param particleDiameter - Particle diameter (m)
 * @param fluidViscosity - Carrier fluid viscosity (Pa·s)
 * @returns Archimedes number
 */
export function archimedesNumber(
  particleDensity: number,
  fluidDensity: number,
  particleDiameter: number,
  fluidViscosity: number
): number {
  const densityDifference = particleDensity - fluidDensity;
  return (
    (densityDifference * fluidDensity * G * Math.pow(particleDiameter, 3)) /
    Math.pow(fluidViscosity, 2)
  );
}

/**
 * Calculate drag coefficient based on Reynolds number
 * @param reynoldsNumber - Particle Reynolds number
 * @returns Drag coefficient
 */
export function dragCoefficient(reynoldsNumber: number): number {
  if (reynoldsNumber < 0.1) {
    // Stokes regime (laminar)
    return 24 / reynoldsNumber;
  } else if (reynoldsNumber < 1000) {
    // Intermediate regime
    return (24 / reynoldsNumber) * (1 + 0.15 * Math.pow(reynoldsNumber, 0.687));
  } else {
    // Newton regime (turbulent)
    return 0.44;
  }
}

/**
 * Calculate particle settling velocity using appropriate correlation
 * @param particleDensity - Particle density (kg/m³)
 * @param fluidDensity - Carrier fluid density (kg/m³)
 * @param particleDiameter - Particle diameter (m)
 * @param fluidViscosity - Carrier fluid viscosity (Pa·s)
 * @param shapeFactor - Particle shape factor (1.0 for spherical)
 * @returns Settling velocity (m/s)
 */
export function settlingVelocity(
  particleDensity: number,
  fluidDensity: number,
  particleDiameter: number,
  fluidViscosity: number,
  shapeFactor: number = 1.0
): {
  froudeNumber: number;
  velocity: number;
  method: 'stokes' | 'intermediate' | 'newton' | 'durand';
  dragCoeff: number;
} {
  const warnings: (string | Warning)[] = [];

  // Validate inputs
  if (
    particleDensity <= 0 ||
    fluidDensity <= 0 ||
    particleDiameter <= 0 ||
    fluidViscosity <= 0
  ) {
    throw new Error('All input parameters must be positive');
  }

  if (particleDensity <= fluidDensity) {
    throw new Error(
      'Particle density must be greater than fluid density for settling'
    );
  }

  if (shapeFactor <= 0) {
    throw new Error('Shape factor must be positive');
  }

  // Calculate Archimedes number
  const ar = archimedesNumber(
    particleDensity,
    fluidDensity,
    particleDiameter,
    fluidViscosity
  );

  let velocity: number;
  let method: 'stokes' | 'intermediate' | 'newton' | 'durand';
  let dragCoeff: number;

  if (ar < 36) {
    // Stokes regime
    velocity =
      ((particleDensity - fluidDensity) * G * Math.pow(particleDiameter, 2)) /
      (18 * fluidViscosity);
    method = 'stokes';
    dragCoeff = 24; // For Re < 0.1
  } else if (ar < 83000) {
    // Intermediate regime
    velocity =
      Math.pow(
        (4 * (particleDensity - fluidDensity) * G * particleDiameter) /
          (3 * fluidDensity),
        0.5
      ) * Math.pow(ar / (18 + 0.6 * Math.pow(ar, 0.5)), 0.5);
    method = 'intermediate';
    dragCoeff = 24 * (1 + 0.15 * Math.pow(ar / 24, 0.687));
  } else {
    // Newton regime
    velocity = Math.pow(
      (3.1 * (particleDensity - fluidDensity) * G * particleDiameter) /
        fluidDensity,
      0.5
    );
    method = 'newton';
    dragCoeff = 0.44;
  }

  // Apply shape factor correction
  velocity = velocity / Math.sqrt(shapeFactor);

  // Check for very small particles (may need special handling)
  if (particleDiameter < 1e-6) {
    warnings.push({
      type: 'general',
      message: 'Very small particles (< 1 μm) may require special correlations',
      severity: 'medium',
    });
  }

  // Check for very large particles
  if (particleDiameter > 0.01) {
    warnings.push({
      type: 'general',
      message: 'Large particles (> 10 mm) may not follow standard correlations',
      severity: 'medium',
    });
  }

  return {
    froudeNumber, velocity, method, dragCoeff };
}

/**
 * Calculate Durand factor for slurry flow
 * @param settlingVelocity - Particle settling velocity (m/s)
 * @param pipeDiameter - Pipe diameter (m)
 * @param flowVelocity - Flow velocity (m/s)
 * @param concentration - Volume concentration (0-1)
 * @returns Durand factor
 */
export function durandFactor(
  settlingVelocity: number,
  pipeDiameter: number,
  flowVelocity: number,
  concentration: number
): number {
  if (flowVelocity <= 0) {
    throw new Error('Flow velocity must be positive');
  }

  if (concentration <= 0 || concentration >= 1) {
    throw new Error('Concentration must be between 0 and 1');
  }

  // Calculate Froude number
  const froudeNumber = flowVelocity / Math.sqrt(G * pipeDiameter);

  // Durand factor calculation
  // C_D = 180 * (V_s / V) * (g * D / V²)^0.5 * C_v^0.5
  const durandFactor =
    180 *
    (settlingVelocity / flowVelocity) *
    Math.pow((G * pipeDiameter) / Math.pow(flowVelocity, 2), 0.5) *
    Math.pow(concentration, 0.5);

  return durandFactor;
}

/**
 * Calculate slurry headloss using Durand correlation
 * @param carrierDensity - Carrier fluid density (kg/m³)
 * @param carrierViscosity - Carrier fluid viscosity (Pa·s)
 * @param flowVelocity - Flow velocity (m/s)
 * @param pipeDiameter - Pipe diameter (m)
 * @param pipeLength - Pipe length (m)
 * @param pipeRoughness - Pipe roughness (m)
 * @param settlingVelocity - Particle settling velocity (m/s)
 * @param concentration - Volume concentration (0-1)
 * @returns Headloss (m)
 */
export function slurryHeadloss(
  carrierDensity: number,
  carrierViscosity: number,
  flowVelocity: number,
  pipeDiameter: number,
  pipeLength: number,
  pipeRoughness: number,
  settlingVelocity: number,
  concentration: number
): {
  froudeNumber: number;
  headloss: number;
  frictionFactor: number;
  durandFactor: number;
} {
  const warnings: (string | Warning)[] = [];

  // Validate inputs
  if (
    carrierDensity <= 0 ||
    carrierViscosity <= 0 ||
    flowVelocity <= 0 ||
    pipeDiameter <= 0 ||
    pipeLength <= 0 ||
    pipeRoughness < 0
  ) {
    throw new Error('All input parameters must be positive');
  }

  if (concentration <= 0 || concentration >= 1) {
    throw new Error('Concentration must be between 0 and 1');
  }

  // Calculate carrier fluid friction factor
  const reynoldsNumber = reynolds(
    carrierDensity,
    flowVelocity,
    pipeDiameter,
    carrierViscosity
  );
  const relativeRoughness = pipeRoughness / pipeDiameter;
  const carrierFrictionFactor = churchillF(reynoldsNumber, relativeRoughness);

  // Calculate carrier fluid headloss
  const carrierHeadloss =
    (carrierFrictionFactor * pipeLength * Math.pow(flowVelocity, 2)) /
    (2 * G * pipeDiameter);

  // Calculate Durand factor
  const durandFactorValue = durandFactor(
    settlingVelocity,
    pipeDiameter,
    flowVelocity,
    concentration
  );

  // Calculate Froude number
  const froudeNumber = flowVelocity / Math.sqrt(G * pipeDiameter);

  // Check applicability limits
  if (froudeNumber < 1.5) {
    warnings.push({
      type: 'general',
      message: 'Froude number < 1.5: Durand correlation may not be applicable',
      severity: 'high',
    });
  }

  if (froudeNumber > 40) {
    warnings.push({
      type: 'general',
      message: 'Froude number > 40: Durand correlation may not be applicable',
      severity: 'high',
    });
  }

  if (concentration > 0.15) {
    warnings.push({
      type: 'general',
      message:
        'High concentration (> 15%): Durand correlation may not be applicable',
      severity: 'medium',
    });
  }

  // Calculate slurry headloss using Durand correlation
  // i_s = i_w * (1 + C_D * C_v)
  const slurryHeadlossValue =
    carrierHeadloss * (1 + durandFactorValue * concentration);

  return {
    froudeNumber,
    headloss: slurryHeadlossValue,
    frictionFactor: carrierFrictionFactor,
    durandFactor: durandFactorValue,
  };
}

/**
 * Calculate settling velocity for slurry particles
 * @param input - Slurry flow input parameters
 * @returns Settling velocity result
 */
export function calculateSettlingVelocity(
  input: SlurryFlowInput
): SettlingVelocityResult {
  const warnings: (string | Warning)[] = [];

  // Convert input parameters to SI units
  const particleDensity = convert(
    input.slurry.particles.density,
    'kg/m³'
  ).value;
  const particleDiameter = convert(input.slurry.particles.diameter, 'm').value;
  const fluidDensity = convert(
    input.slurry.carrierFluid.density,
    'kg/m³'
  ).value;
  const fluidViscosity = convert(
    input.slurry.carrierFluid.viscosity,
    'Pa·s'
  ).value;

  // Get shape factor
  const shapeFactor = input.slurry.particles.shape
    ? SHAPE_FACTORS[input.slurry.particles.shape]
    : 1.0;

  // Calculate settling velocity
  const { velocity, method, dragCoeff } = settlingVelocity(
    particleDensity,
    fluidDensity,
    particleDiameter,
    fluidViscosity,
    shapeFactor
  );

  // Calculate particle Reynolds number
  const particleRe = particleReynolds(
    fluidDensity,
    velocity,
    particleDiameter,
    fluidViscosity
  );

  // Calculate Archimedes number
  const ar = archimedesNumber(
    particleDensity,
    fluidDensity,
    particleDiameter,
    fluidViscosity
  );

  // Add warnings for extreme conditions
  if (particleRe > 1000) {
    warnings.push({
      type: 'general',
      message: 'High particle Reynolds number: turbulent settling regime',
      severity: 'medium',
    });
  }

  if (ar > 100000) {
    warnings.push({
      type: 'general',
      message:
        'Very high Archimedes number: Newton regime with high uncertainty',
      severity: 'medium',
    });
  }

  return {
    froudeNumber,
    settlingVelocity: { value: velocity, unit: 'm/s' },
    reynoldsNumber: particleRe,
    dragCoefficient: dragCoeff,
    method,
    warnings,
    metadata: {
      input,
      calculations: {
        particleReynolds: particleRe,
        archimedesNumber: ar,
        shapeFactor,
      },
    },
  };
}

/**
 * Calculate slurry headloss using Durand correlation
 * @param input - Slurry flow input parameters
 * @returns Slurry headloss result
 */
export function calculateSlurryHeadloss(
  input: SlurryFlowInput
): SlurryHeadlossResult {
  const warnings: (string | Warning)[] = [];

  // Convert input parameters to SI units
  const carrierDensity = convert(
    input.slurry.carrierFluid.density,
    'kg/m³'
  ).value;
  const carrierViscosity = convert(
    input.slurry.carrierFluid.viscosity,
    'Pa·s'
  ).value;
  const flowVelocity = convert(input.velocity, 'm/s').value;
  const pipeDiameter = convert(input.pipe.diameter, 'm').value;
  const pipeLength = convert(input.pipe.length, 'm').value;
  const pipeRoughness = convert(input.pipe.roughness, 'm').value;

  // Convert concentration to volume fraction
  let concentration: number;
  if (input.slurry.concentrationType === 'volume') {
    concentration = convert(input.slurry.concentration, 'dimensionless').value;
  } else {
    // Convert weight fraction to volume fraction
    const particleDensity = convert(
      input.slurry.particles.density,
      'kg/m³'
    ).value;
    const weightFraction = convert(
      input.slurry.concentration,
      'dimensionless'
    ).value;
    concentration =
      weightFraction /
      particleDensity /
      (weightFraction / particleDensity +
        (1 - weightFraction) / carrierDensity);
  }

  // Calculate settling velocity
  const particleDensity = convert(
    input.slurry.particles.density,
    'kg/m³'
  ).value;
  const particleDiameter = convert(input.slurry.particles.diameter, 'm').value;
  const shapeFactor = input.slurry.particles.shape
    ? SHAPE_FACTORS[input.slurry.particles.shape]
    : 1.0;

  const { velocity: settlingVelocityValue } = settlingVelocity(
    particleDensity,
    carrierDensity,
    particleDiameter,
    carrierViscosity,
    shapeFactor
  );

  // Calculate slurry headloss
  const {
    headloss,
    frictionFactor,
    durandFactor: durandFactorValue,
  } = slurryHeadloss(
    carrierDensity,
    carrierViscosity,
    flowVelocity,
    pipeDiameter,
    pipeLength,
    pipeRoughness,
    settlingVelocityValue,
    concentration
  );

  // Calculate pressure drop
  const pressureDrop = headloss * carrierDensity * G;

  // Calculate relative roughness
  const relativeRoughness = pipeRoughness / pipeDiameter;

  // Calculate Reynolds number
  const reynoldsNumber = reynolds(
    carrierDensity,
    flowVelocity,
    pipeDiameter,
    carrierViscosity
  );

  // Add concentration effect calculation
  const concentrationEffect = 1 + durandFactorValue * concentration;

  // Calculate Froude number
  const froudeNumber = flowVelocity / Math.sqrt(G * pipeDiameter);

  // Add warnings for applicability
  if (froudeNumber < 1.5 || froudeNumber > 40) {
    warnings.push({
      type: 'general',
      message: `Froude number (${froudeNumber.toFixed(2)}) outside recommended range (1.5-40)`,
      severity: 'high',
    });
  }

  if (concentration > 0.15) {
    warnings.push({
      type: 'general',
      message: `High concentration (${(concentration * 100).toFixed(1)}%): Durand correlation may not be applicable`,
      severity: 'medium',
    });
  }

  if (particleDiameter / pipeDiameter > 0.1) {
    warnings.push({
      type: 'general',
      message:
        'Large particle-to-pipe diameter ratio: Durand correlation may not be applicable',
      severity: 'high',
    });
  }

  return {
    froudeNumber,
    headloss: { value: headloss, unit: 'm' },
    pressureDrop: { value: pressureDrop, unit: 'Pa' },
    frictionFactor,
    relativeRoughness,
    durandFactor: durandFactorValue,
    froudeNumber,
    concentrationEffect,
    warnings,
    metadata: {
      input,
      calculations: {
        reynoldsNumber,
        carrierFrictionFactor: frictionFactor,
        settlingVelocity: settlingVelocityValue,
        concentration,
      },
    },
  };
}
